package fi.solita.utils.functional;

import static fi.solita.utils.functional.Collections.newArray;
import static fi.solita.utils.functional.Collections.newMap;
import static fi.solita.utils.functional.FunctionalImpl.map;
import static fi.solita.utils.functional.Option.None;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Map;

public final class Builder<T> {
    public static final class IncompleteException extends RuntimeException {
        public IncompleteException(Apply<?, ?> member) {
            super("Missing value for member " + member);
        }
    }

    private final Collection<? extends Apply<? super T,? extends Object>> members;
    private final Map<Apply<? super T, ? extends Object>, Object> values;
    private final Apply<Tuple, T> constructor;

    @SuppressWarnings("unchecked")
    private <F1,F2> Builder(Map<Apply<? super T,? extends Object>,Object> values, Collection<? extends Apply<? super T, ? extends Object>> members, Apply<? extends Tuple, T> constructor) {
        this.members = members;
        this.values = values;
        this.constructor = (Apply<Tuple, T>) constructor;
    }
    
    public static <T,F1> Builder<T> of(Tuple1<? extends Apply<? super T,F1>> members, Apply<F1,T> constructor) {
        return newBuilder(Tuple.asList(members), Function.of(constructor).tuppled());
    }

    public static <T,F1,F2> Builder<T> of(Tuple2<? extends Apply<? super T,F1>,? extends Apply<? super T,F2>> members, Apply<Tuple2<F1,F2>,T> constructor) {
        return newBuilder(Tuple.asList(members), constructor);
    }
    
    public static <T,F1,F2,F3> Builder<T> of(Tuple3<? extends Apply<? super T,F1>,? extends Apply<? super T,F2>,? extends Apply<? super T,F3>> members, Apply<Tuple3<F1,F2,F3>,T> constructor) {
        return newBuilder(Tuple.asList(members), constructor);
    }
    
    private static <T> Builder<T> newBuilder(Collection<? extends Apply<? super T, ? extends Object>> members, Apply<? extends Tuple, T> constructor) {
        return new Builder<T>(Collections.<Apply<? super T, ? extends Object>,Object>emptyMap(), members, constructor);
    }

    public final Builder<T> init(final T t) {
        Map<Apply<? super T, ? extends Object>, Object> newValues = newMap(map(members, new Transformer<Apply<? super T,? extends Object>, Pair<Apply<? super T,? extends Object>,Object>>() {
            @SuppressWarnings("unchecked")
            @Override
            public Pair<Apply<? super T,? extends Object>,Object> transform(Apply<? super T,? extends Object> source) {
                return (Pair<Apply<? super T,? extends Object>,Object>)(Object)Pair.of(source, source.apply(t));
            }
        }));
        return new Builder<T>(newValues, members, constructor);
    }

    public final <F1> Builder<T> with(final Apply<T,? super F1> member, final F1 newValue) {
        checkMember(member);
        return new Builder<T>(Functional.with(member, newValue, values), members, constructor);
    }
    
    public final Builder<T> without(final Apply<T,? extends Option<?>> member) {
        checkMember(member);
        return new Builder<T>(Functional.with(member, None(), values), members, constructor);
    }

    private void checkMember(final Apply<T, ?> member) {
        if (!members.contains(member)) {
            throw new IllegalArgumentException(member.toString());
        }
    }

    public final T build() throws IncompleteException {
        return constructor.apply(Tuple.of(newArray(Object.class, map(members, new Transformer<Apply<? super T,? extends Object>,Object>() {
            @Override
            public Object transform(Apply<? super T, ? extends Object> member) {
                if (values.containsKey(member)) {
                    return values.get(member);
                } else {
                    try {
                        // argh, if the field happens to be generated by meta-utils, as expected...
                        Method fieldAccessor = member.getClass().getMethod("getMember");
                        Class<?> fieldType = ((Field)fieldAccessor.invoke(member)).getType();
                        if (Option.class.isAssignableFrom(fieldType)) {
                            return None();
                        }
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException(e);
                    } catch (InvocationTargetException e) {
                        throw new RuntimeException(e);
                    } catch (NoSuchMethodException e) {
                        // continue...
                    }
                }
                throw new IncompleteException(member);
            }
        }))));
    }
}
